##### messages / types
typedef string Datetime

# generic structs
struct Range { Datetime start, Datetime end }

# @FH: I always get errors when defining any arrays
# Are arrays not supported in structs / message?
# processingTimes / numberOfMachines should be an array
struct TaillardProblem {int processingTimes, int order, int numberOfMachines, int numberOfJobs}
struct Task {string machineId, string jobId, string operationId, int processingTime}
struct SolutionCandidate {Task tasks}
struct Objective {string name, float value}


# MachineInformation/UnavailablePeriod should be a array
struct UnavailablePeriod {Range range, string reason} #@FH rethink the integration of ENUMS for e.g., reasons
struct MachineInformation {string machineId, UnavailablePeriod unavailablePeriods}
struct ShopFloorInformation {string shopFloorId, MachineInformation machineInformation}

message GenerateRequest {int time, int numberOfMachines, int numberOfJobs}
message SchedulingRequest {TaillardProblem problem}
message EvaluationRequest {SolutionCandidate sc, TaillardProblem problem}
# @FH objectives should be an array
# message EvaluationResponse {Objective[] objectives, string source}
# Alternative, but cumbersome:
typedef Objective[] Objectives
message EvaluationResponse {Objectives objectives, string source}
message TrainingSample {EvaluationRequest request, EvaluationResponse response}
message MachineInformationRequest {string shopFloorIdentifier}
message MachineInformationResponse {string shopFloorIdentifier}


# @FH  notetype declaration requires default values for properties

##### nodes
nodetype TimerService {
    # generates scheduling problems - in the real world this can be replaced by other data sources
    output GenerateRequest request

    property int updateFrequencyInSeconds
}
nodetype ProblemGenerator {
    # generates scheduling problems - in the real world this can be replaced by other data sources
    input GenerateRequest request
    output SchedulingRequest schedulingRequest
}

nodetype MachineInformationService {
    # node knows about information of the machine (available times etc.)
    input MachineInformationRequest request
    input MachineInformationResponse response
}

nodetype OptimizationService {
    input EvaluationRequest request
    output EvaluationRequest response

    property string[] objectives
}


# evaluation node which falls back to simulation / approximation with surrogate / ...
nodetype FitnessEvaluationSimulation {
    input EvaluationRequest request
    output EvaluationResponse response

    property string[] objectives
}

nodetype FitnessSurrogate {
    # learns from the same request as the simulation
    input EvaluationRequest request
    output EvaluationResponse response
}

nodetype Sink {
    # saves the candidate as the current best - for visualization / ...
    input EvaluationRequest request
    output EvaluationResponse response
    property string storagelocationURL
}



# # string[] objectives = ["c-max", "t-j"]
string objectives = "c-max"

node TimerService timer
node ProblemGenerator generator
node MachineInformationService machineInformation
node OptimizationService optimization
node FitnessEvaluationSimulation simulation
node FitnessSurrogate surrogate
node Sink sink(storagelocationURL = "REST URL")

# # instantiations
# # @FH: when you find a surrogate we automatically need a service which takes (request + response) and does some normalization (for training)
# # Then when the targetPerformance is reached we need to add another service which actual acts as a surrogate
# FitnessSurrogate surrogate imitates simulation {
#   targetPerformance = 0.8,
#   performanceMeasure = "MAPE"
# }

# ##### Graph
# # @FH: in some of those cases the communication is bidirectional - is a single arrow enough?
timer --> generator
generator --> machineInformation
generator --> optimization
optimization --> simulation
optimization --> sink