<!DOCTYPE html>
	<html lang="en">
		<head>
			<meta charset="UTF-8">
	  		<meta name="viewport" content="width=device-width, initial-scale=1.0">
			<title>Sidl Visualization: Graph</title>

			<!-- vis.js -->
			<script src="${res}/js/vis-data.min.js" type="text/javascript"></script>
			<script src="${res}/js/vis-network.min.js" type="text/javascript"></script>
			<link rel="stylesheet" type="text/css" media="all" href="${res}/css/vis-network.min.css" />

			<link rel="stylesheet" type="text/css" media="all" href="${res}/css/main.css" />
		</head>
		<body>
			<div id="doctext"></div>
			<div id="graphobj"></div>
			<div id="graph"></div>

			<script type="text/javascript">
				var uri = "${uri}";
				var filename = "${filename}";

				// graph visualizaiton (vis.js)
				var graph, nodes, edges, data, container, options;
				var nodesDict, nodesArr, edgesDict, edgesArr, nodeNamesDict;
				var nodeEdgeCounter;
									
				
				const text = document.getElementById('doctext');
				const graphobj = document.getElementById('graphobj');

				window.addEventListener('message', event => {
					const cmd = event.data.cmd;
					const graphdata = event.data.graph;

					if(cmd == "init") {
						initGraph(graphdata);
					} else if(cmd == "update") {
						processGraph(graphdata);
					}				
				});

				// vis node styles				
				var changeChosenNodeLabel = function(values, id, selected, hovering) {
					values.color = '#000000';
					//values.mod = 'bold';
				}

				var changeChosenNode = function(values, id, selected, hovering) {
					values.borderColor = '#000000';
				}

				var nc0 = {margin: 12, shape: 'circle', borderWidth: 2, borderWidthSelected: 2, chosen: {label: changeChosenNodeLabel, node: changeChosenNode},
					color: {background: '#ffffff', border: '#666666'}, 
					font: {multi: 'html', color: '#666666', face: 'Open Sans'}
				};

				// vis edgle styles
				var ec0 = {length: 400, width: 1, color: {color: '#333333'}, dashes:false, arrows: {to: {enabled: true, scaleFactor: 0.5}}, chosen: {label: ccelOnClicked, edge: cceOnClicked}}; // default
				
				var cceOnClicked = function(values, id, selected, hovering) {
					values.width = 2;
					values.color = '#333333';
				};

				var ccelOnClicked = function(values, id, selected, hovering) {
					values.mod = 'bold';
				};

				var cceOnFromNodeClicked = function(values, id, selected, hovering) {
					values.width = 2;
					values.color = '#f95f6f';
				};

				var cceOnToNodeClicked = function(values, id, selected, hovering) {
					values.width = 2;
					values.color = '#00e5d4';
				};

				var echfrom = { chosen: {label: ccelOnClicked, edge: cceOnFromNodeClicked} };
				var echto = { chosen: {label: ccelOnClicked, edge: cceOnToNodeClicked} };
				

				function initGraph(graphrec) {
					nodesDict = {};
					nodesArr = [];					
					edgesDict = {};
					edgesArr = [];
					nodeEdgeCounter = [];

					var count = 1;					
					for(var n of graphrec.nodes) {						
						var obj = {};
						Object.assign(obj, nc0);
						obj.id = n.name;
						obj.label = n.name;
						nodesArr.push(obj);						
						count++;
					}
					
					for(var e of graphrec.edges) {
						var obj = {};
						Object.assign(obj, ec0);
						obj.id = e.from + "-->" + e.to;
						obj.label = e.payload;
						obj.from = e.from;
						obj.to = e.to;
						edgesArr.push(obj);						
					}					
					
					container = document.getElementById("graph");
					
					nodes = new vis.DataSet(nodesArr);
					edges = new vis.DataSet(edgesArr);
					
					data = {
						nodes: nodes,
						edges: edges
					};
					options = {
						layout: {
							hierarchical: {
								direction: "DU", // LR, 
								sortMethod: "directed",
								parentCentralization: true
							}
						}, 
						physics: {
    						enabled: false
						}
					};
					
					graph = new vis.Network(container, data, options);
					
				}		
				
				function processGraph(graphrec) {
					if(!graphrec) return;

					var newNodesArr = [];										
					var newEdgesArr = [];
					var newNodesDict = {};
					var newEdgesDict = {};

					// collect new graph data
					for(var n of graphrec.nodes) {
						newNodesDict[n.name] = {
							id: n.name,
							label: n.name
						};

						var obj = {};
						Object.assign(obj, nc0);
						obj.id = n.name;
						obj.label = n.name;
						newNodesArr.push(obj);
					}

					for(var e of graphrec.edges) {
						newEdgesDict[n.name] = {
							id: e.from + "-->" + e.to,
							label: e.payload,
							from: e.from,
							to: e.to
						};

						var obj = {};
						Object.assign(obj, ec0);
						obj.id = e.from + "-->" + e.to;
						obj.label = e.payload;
						obj.from = e.from;
						obj.to = e.to;
						newEdgesArr.push(obj);
					}

					// remove old graph data
					for(var n of nodesArr) {
						var node = newNodesDict[n.name];
						if(!node) {
							data.nodes.remove([n.name]);
							console.log("removing: " + n.name);
						}
					}
					for(var e of edgesArr) {
						var id = e.from + "-->" + e.to;
						var edge = newEdgesArr[id];
						if(!edge) {
							console.log("removing: " + id);
							data.edges.remove([id]);
						}
					}

					edgesArr = newEdgesArr;
					nodesArr = newNodesArr;
					data.edges.update(edgesArr);
					data.nodes.update(nodesArr);					
				}

			</script>
		</body>
	</html>